# Default values for peerpods (CAA) chart

# Secret configuration
secrets:
  # How to handle provider secrets:
  #
  # - "create": Helm creates the K8s Secret from providerSecrets values.
  #   WARNING: Not recommended for production. Secrets passed via helm install
  #   are stored in Helm release history and can be retrieved with `helm get values`.
  #
  # - "reference": Reference a pre-existing K8s Secret by name.
  #   Recommended for production. Secrets are managed externally (kubectl, Vault,
  #   External Secrets Operator, etc.) and never flow through Helm.
  #
  # Future modes may include: "eso" (External Secrets Operator), "sealed" (Sealed Secrets), etc.
  #
  mode: "create"

  # Name of existing secret for provider credentials (only used when mode: "reference")
  # The secret must contain the required env var keys for your provider.
  # See providers/*-secrets.yaml.template for the list of required keys.
  existingSecretName: ""

  # Name of existing SSH key secret for libvirt (only used when mode: "reference")
  # The secret must contain the private key (id_rsa) for connecting to the hypervisor.
  existingSshKeySecretName: ""

  # TLS certificates for CAA-to-peer-pod communication.
  #
  # TLS between CAA and agent-protocol-forwarder is always enabled. By default,
  # CAA auto-generates certificates in memory and no configuration is needed.
  #
  # To use custom certificates, two things are required:
  #
  # 1. Provide the certificate files below (create mode) or via an external
  #    secret (reference mode, see existingTlsSecretName)
  # 2. Set CACERT_FILE, CERT_FILE, CERT_KEY in providerConfigs pointing to
  #    /etc/certificates/ca.crt, client.crt, client.key respectively
  #
  # This two-step approach matches the kustomize deployment flow. A future
  # improvement may auto-derive the env vars from the certificate files.
  #
  # Three modes:
  #
  # 1. Automatic (default): Do not set CACERT_FILE/CERT_FILE/CERT_KEY in
  #    providerConfigs. CAA auto-generates certs in memory. Nothing to
  #    configure.
  #
  # 2. Custom certs, create mode (secrets.mode: "create"): Provide cert
  #    files via --set-file into secrets.tlsCerts and set the env vars in
  #    providerConfigs. Helm creates the certs-for-tls secret and mounts
  #    it at /etc/certificates.
  #
  # 3. Custom certs, reference mode (secrets.mode: "reference"): Set
  #    existingTlsSecretName to a secret you manage externally (must
  #    contain keys: ca.crt, client.crt, client.key) and set the env
  #    vars in providerConfigs. Helm only creates the volume mount.

  # Name of existing TLS secret (only used when mode: "reference")
  existingTlsSecretName: ""

  # Certificate files for custom TLS (only used when mode: "create").
  # Provide via --set-file, e.g.: --set-file secrets.tlsCerts.caCert=./ca.crt
  tlsCerts:
    caCert: ""
    clientCert: ""
    clientKey: ""

# CAA (Cloud API Adaptor) image
#
# Two image variants are published:
# - Release image (<commit>): smaller, no CGO/libvirt bindings
# - Dev image (dev-<commit> or "latest"): includes CGO bindings for libvirt/docker
#
# During development: "latest" works for all providers
# At release: most providers use <commit>, libvirt/docker use dev-<commit>
#
# Note: libvirt/docker provider files override this with the dev image.
image:
  name: quay.io/confidential-containers/cloud-api-adaptor
  tag: "latest"

# Cloud provider: libvirt, aws, azure, gcp, ibmcloud, vsphere
provider: libvirt

# Maximum number of peer pods allowed to run simultaneously
# This limit prevents resource exhaustion on the cloud provider
# Set to "0" for unlimited (not recommended for production)
limit: "10"

# DaemonSet configuration
daemonset:
  # Update strategy controls how the CAA DaemonSet performs rolling updates
  updateStrategy:
    # maxUnavailable: Maximum number of pods that can be unavailable during update
    # maxSurge: Maximum number of extra pods that can be created during update
    #
    # Default (maxUnavailable: 0, maxSurge: 1) provides zero downtime updates
    # and works on both small (1 node) and large clusters.
    # Override with custom values for specific deployment needs.
    maxUnavailable: 0
    maxSurge: 1
  # A free-form map which can be used to inject provider-specific or platform-specific labels.
  #
  # Example (Azure Workload Identity):
  # podLabels:
  #   azure.workload.identity/use: "true"
  # NOTE:
  # - Keys may contain dots (.) and slashes (/)
  # - When setting via CLI, prefer --set-json or a values file (plain --set will interpret dots as map nesting)
  podLabels: {}

# peerpod-ctrl subchart configuration
# Manages lifecycle of peer pod cloud resources and cleans up dangling VMs
# Configuration options documented in ../../../peerpod-ctrl/chart/values.yaml
resourceCtrl:
  enabled: true

# peerpods-webhook subchart configuration
# Mutating webhook that modifies pod specs to use peer pods runtime and resources
# Configuration options documented in ../../../webhook/chart/values.yaml
# NOTE: Requires cert-manager to be installed in the cluster
webhook:
  enabled: true

# kata-deploy subchart configuration
kata-deploy:
  # Installs kata and the kata-remote RuntimeClass required by peer pods.
  # Set to false if kata is already installed (e.g., via another chart or operator).
  # If disabled, ensure kata-remote shim is enabled otherwise CAA will not work.
  enabled: true
  snapshotter:
    setup: ["nydus"]
  defaultShim:
    amd64: remote
    arm64: remote
    s390x: remote
    ppc64le: remote
  shims:
    clh:
      enabled: false
    cloud-hypervisor:
      enabled: false
    dragonball:
      enabled: false
    fc:
      enabled: false
    qemu:
      enabled: false
    qemu-runtime-rs:
      enabled: false
    qemu-nvidia-gpu:
      enabled: false
    qemu-nvidia-gpu-snp:
      enabled: false
    qemu-nvidia-gpu-tdx:
      enabled: false
    qemu-snp:
      enabled: false
    qemu-tdx:
      enabled: false
    qemu-se:
      enabled: false
    qemu-se-runtime-rs:
      enabled: false
    qemu-cca:
      enabled: false
    qemu-coco-dev:
      enabled: false
    qemu-coco-dev-runtime-rs:
      enabled: false
    remote:
      enabled: true
